<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    body{
      height: 100px;
    }
  </style>
</head>
<body>
  <script>
    // 함수
    // 기능(동작)을 수행하는 코드의 집합
    // 변수와 마찬가지로 한 번 선언해두고 재활용이 가능하다

    // 함수의 선언과 호출하는 방법(구조)↓↓↓
    // function키워드 함수이름(매개변수) { 실행블록 안에 실행코드 };
    // 매개변수(옵션) : 외부로부터 받을 값(데이터)을 저장하는 곳으로, 값이 없으면 필수로 적지 않아도 된다.
    // 실행블록 : 실행할 코드를 작성
  
    // 선언이 끝나면 필요한 곳에서 호출해서 사용하면 된다
    // 함수이름();
    // 실행블록 안에 여러 가지 코드가 한 번에 실행됨

    //함수 선언함↓
    function helloFunc( ) {       // 함수이름, 변수명은 카멜케이스로 정한다(에러는 없더라도)
      console.log(1234);
    }

    //호출 선언
    helloFunc();
    helloFunc();
    helloFunc(); //계속 호출 선언할 수 있음(재호출 가능)

    // 함수의 데이터 반환
    // 내부에서 return 키워드를 사용하면 데이터를 반환하고 함수가 종료된다
    // 예) 계산기의 덧셈 기능과 같이 결과값을 내줌
    function returnFunc() {
      console.log('ABC')
      console.log('ABC')
      return 123;
      console.log('ABC'); //이 줄은 return 뒤(아랫줄)에 있어서 실행되지 않음
    }

    returnFunc(); // 호출선언 > 123이 리턴(반환) 되고 returnFunc은 종료된다.
    const a = returnFunc(); // 실행 결과 반환되는 값을 변수 a에 할당함
    console.log(a);


    function returnFunction() {
      return; //함수 종료, return뒤에 아무것도 없으니까 반환할 내용 없음
      console.log('ABC'); //이 줄은 return 뒤(아랫줄)에 있어서 실행되지 않음
    }

    returnFunction();
    const b = returnFunction(); 
    console.log(b);


    // 선언된 함수 재사용
    // 유효한 범위 내에서 재사용이 가능하다
    function sum(num1, num2) { //num1, num2는 매개변수(Parameter)라고 부른다
      //우리는 매개변수를 사용해서 함수 외부로부터 값을 받아서 내부에서 값을 쓴다
      return num1 + num2;
    }

    sum(1, 2); //호출 "함수이름();" // 전단하는 값 1, 2를 인수(또는 인자값 Argument)이라고 부름 //함수도 재사용 가능하다! "sum(인자값, 인자값)"
    const result1 = sum(1, 2);
    const result2 = sum(7, 3); 
    const result3 = sum(2, 9);

    console.log(result1 , result2, result3);

    // 함수도 기명(이름이 있는) 함수와 익명(이름이 없는) 함수가 있다
    // 일반적으로는 함수에는 이름이 존재하지만, 때로는 없을 수 있다.
    // 함수는 그 자체가 값(데이터)으로 변수에 할당이 가능하기 때문이다. ( 익명일 때 변수의 이름이 곧 함수의 이름으로 쓰인다)

    // 기명 함수
    // 함수 선언문
    function hello() {
      console.log('Hello~');
    }
    hello();

    // 익명함수
    // 함수 표현식
    //익명 함수는 이름이 없기 때문에 변수에 할당하지 않으면 재사용 불가능하다
    //변수를 선언하고 그 변수에다가 함수를 쓴다
    const world = function() {
      console.log('World!');
    }
    world();

    // 함수는 그 자체가 하나의 값(데이터)이라 함수를 호출할 때 인수로 사용 가능하다 =>콜백 함수라 부른다
    function handler() {
      console.log('Chicked!');
    }

    document.body.addEventListener('click', handler); //'click' - w3c 에서 html event 리스트에 있는 거로 갖다가 쓸 수 있다 // 클릭하면, handler 함수를 호출한다! 
    handler();
    handler(); // 총 3번 재사용, 재사용 가능함

    // 함수를 재사용 할 필요가 없으면(1회성) 굳이 이름을 붙이지 않고 익명함수를 사용한다
    document.body.addEventListener('click', function () { //콜백 함수라 부르고
      console.log('익명함수!');
    }); // 1회성, 여기서 선언하고 끝나는 함수이다

    // 메소드에 대해
    // 객체에 저장하는 데이터가 함수인 경우, 그 속성을 메소드라 부른다
    // 자신이 속한 객체의 각 속성에 this라는 키워드로 접근이 가능하다
    const user ={
      name: 'GONI.KIM', // 객체 : '객체값',
      age: 99,          // 객체 : '객체값',
      isValid: true,     //객체 : '객체값'
      getName: function() { //여기서 getName은 메소드이고 값으로 익명 함수를 저장한다
        return this.name;
      }
    }; //객체의 속성으로 함수로 되어 있는 getname을 메소드라고 한다
    
    // this는 객체 자기 자신을 가르킨다
    user.getName(); //메소드 호출
    const hisName = user.getName(); // 변수에 할달해서 호출함
    console.log(hisName);

    // 변수 할당('const a = b') 없이 바로 사용해도 됨
    console.log(user.getName());

    // 변수 할당하고 안하고의 차이점 : 변수에 할당하면 함수(메소드) 호출 한 번으로 해당 데이터를 재사용 가능하기 때문이다.



  </script>
</body>
</html>