<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>javascript 내장 객체</title>
  <script>
    //2. 내장 객체(JS 기본 제공)
    // 자바스크립트 엔진에 내장되어 필여한 경우 생성하여 사용하면 됨
    // 객체명이 대문자로 시작함

    // 1) 날짜 정보 객체 : 날짜와 시간에 대한 정보를 제공
    // 변수 = new Date();
    // 날짜 관련 객체의 사용성이 떨어져서 외부 날짜 라이브러리 moment.js, day.js 사용을 추천함

    // 오늘 날짜에 대한 정보를 가지고 있는 객체 생성
    const today = new Date();
    const nowYear = today.getFullYear();
    const nowMonth = today.getMonth(); // 현재 월보다 1 적게 나옴
    const nowDate = today.getDate(); 
    const nowDay = today.getDay(); // 요일은 0 ~ 6으로 표시함, 0 = 일, 6 = 토

    document.write('<h1>오늘 날짜 정보</h1>');
    document.write(`현재 연도: ${nowYear}<br>`);
    document.write(`현재 월: ${nowMonth + 1}<br>`);
    document.write(`현재 일: ${nowDate}<br>`);
    document.write(`현재 요일: ${nowDay}<br>`);
    document.write(`현재 요일: ${today}<br>`);

    // 특정 날짜 정보를 갖는 날짜 객체 생성
    // new Date(연, 월, 일, 시, 분, 초, 밀리초);
    // 변수 = new Date(연, 월 + 1, 일); // 월은 원하는 월보다 -1 적은 월 수를 적는다 예: 12월을 원하면 11 값을 넣거나 월 값에 +1으 해준다
    // 변수 = new Date('2023/12/31');
    // 변수 = new Date('2023-12-31');
    const someDay = new Date(2023, 11, 31);
    const theYear = someDay.getFullYear();
    const theMonth = someDay.getMonth(); // 현재 월보다 1 적게 나옴
    const theDate = someDay.getDate(); 
    const theDay = someDay.getDay(); // 요일은 0 ~ 6으로 표시함, 0 = 일, 6 = 토

    document.write('<h1>특정 날짜 정보</h1>');
    document.write(`특정 연도: ${theYear}<br>`);
    document.write(`특정 월: ${theMonth + 1}<br>`);
    document.write(`특정 일: ${theDate}<br>`);
    document.write(`특정 요일: ${theDay}<br>`);

    // 특정 날짜까지 D-day 구하기
    // 남은 일 수(밀리초) = 특정 날짜 객체 시간 - 현재 날짜 객체 시간
    // 1초 = 1000ms
    // 1분(60초) = 1000 * 60
    // 1시간(60분) = 1000 * 60 * 60
    // 1일(24시간) = 1000 * 60 * 60 * 24
    const classEndDate = new Date(2023, 2, 10); // 2023-03-10
    const diffDate = classEndDate.getTime() - new Date().getTime(); 
    // // new Date()는 오늘 날짜를 나타냄, getTime()은 밀리초로 반환함
    // // getTime()은 1970년 1월 1일 0시 0분 0초로부터 지금까지 몇 ms가 지났는지를 반환해준다.

    const result = Math.ceil(diffDate / (1000 * 60 * 60 * 24)); // Math.ceil() 올림 수학 함수, 0.2시간 남은 것도 D-1이 남은 거니까
    document.write('<h1>오늘부터 종강까지 남은 날짜</h1>');
    document.write(`D-day: ${result}일 남았습니다.`);
    console.log(diffDate);



    // 2) 수학 객체: 수학 관련 기능과 속성을 제공
    // 객체 생성을 하지 않고 사용 가능 =>정적(static) 객체 라고 명명
    // Math.메소드명();  (예) Math.ceil();
    // Math.속성명;  (예) Math.PI;
  
    // 2)-1. 최대값, 최소값
    document.write('<h1>수학 객체 사용</h1>');
    const num = 2.2134;
    const maxNum = Math.max(10, 5, 8, 30); //최대값 구하는 객체
    document.write(maxNum, '<br>');
    const minNum = Math.min(10, 5, 8, 30); //최소값 구하는 객체
    document.write(minNum, '<br>');


    // 2)-2. 소수 반올림, 내림, 올림
    const roundNum = Math.round(num); // 소수 첫째 자리 반올림
    const floorNum = Math.floor(num); // 소수 첫째 자리 내림 - floor바닥
    const ceilNum = Math.ceil(num); // 소수 첫째 자리 올림 - ceil천장
    document.write(roundNum, '<br>');
    document.write(floorNum, '<br>');
    document.write(ceilNum, '<br>');

    // 랜덤 수 자동생성
    const randomNum = Math.random(); // 0이상 1미만의 난수 발생(실수값)
    document.write(randomNum, '<br>');

    document.write(Math.PI, '<br>');


    // random()을 이용한 특정 범위의 랜덤한 정수값 구하기
    document.write('<h1>특정 범위의 랜덤한 정수값 구하기</h1>');
    // 0 <= Math.random() < 1 (0이상 1미만의 랜덤한 실수값)
    document.write(randomNum, '<br>');

    // 0 <= Math.random() * 10 < 10 (0이상 10미만의 랜덤한 실수값)
    document.write(randomNum * 10, '<br>');

    // 0 <= Math.floor(Math.random() * 10) < 10 (0이상 10미만의 랜덤한 정수값 = 0~9까지 랜덤한 정수값)
    document.write(Math.floor(Math.random() * 10), '<br>');

    // 1 <= Math.floor(Math.random() * 10) + 1 < 11 (1이상 11미만의 랜덤한 정수값 = 0~9까지 랜덤한 정수값)
    document.write(Math.floor(Math.random() * 10) + 1, '<br>');

    // // 컴퓨터가 내려가는 가위, 바위, 보 맞추기!
    // document.write('<h1>컴퓨터가 내려가는 가위, 바위, 보 맞추기!</h1>');
    // const game = prompt('가위, 바위, 보 중 선택하세요.', '가위');
    // let gameNum;

    // switch (game) {
    //   case '가위':
    //     gameNum = 1;
    //     break;
    //   case '바위':
    //     gameNum = 2;
    //     break;
    //   case '보':
    //     gameNum = 3;
    //     break;
    //   default:
    //     alert('잘못 작성하셨습니다.');
    //     location.reload();
    //     break;
    // }

    // // 1~3 사이의 정수값 난수 발생
    // const com = Math.floor(Math.random() * 3) + 1;
    // document.write(`<img src="images/math_img_${com}.jpg"><br>`);
    // if (com === gameNum) {
    // document.write(`<img src="images/game_1.jpg"><br>`);
    // }else{
    // document.write(`<img src="images/game_2.jpg"><br>`);
    // }
    







    // 3) 배열 객체 : 변수에는 하나의 데이터만 저장 가능, 배열에는 여러 개의 데이터를 순차적으로 하나의 저장소에 저장
    // 배열은 하나의 객체이다
    // 예 : 학생 30명의 시험점수를 저장하려면 30개의 변수가 필요한데, 배열을 이용하면 하나의 배열로 30개의 데이터를 저장 가능

    // 배열 객체 생성 3가지 방식
    // 첫번째 방식
    // 변수 = new Array(값1, 값2, 값3);

    // 두번째 방식
    // 변수 = new Array(); // 비어있는 배열 객체를 만들어 놓고 값을 그 다음에 넣는 방식
    // 변수[0] = 값1;
    // 변수[1] = 값2;
    // 변수[2] = 값3;

    // 세번째 방식
    // 변수 = [값1, 값2, 값3]; => 리터럴 방식

    // 배열에 접근하기
    // 배열의 인덱스는 0부터 시작
    // 변수[인덱스 번호] 로 접근 가능 (예) arrayList[0]
    
    // 배열에 저장된 값 출력하기(여러가지 방법 존재)
    const arr = [30, '따르릉', true]; // 보통은 똑같은 자료형이 들어가고, 주로 객체가 들어감

    document.write('<h3>배열값 가져오기-1</h3>');
    document.write(arr[0], '<br>');
    document.write(arr[1], '<br>');
    document.write(arr[2], '<br>');

    document.write('<h3>배열값 가져오기-2</h3>');
    for (let i = 0 ; i < arr.length; i++) { // arr.length는 arr 배열의 개수를 반환함 = 3과 동일
      document.write(arr[i], '<br>');
    }

    document.write('<h3>배열값 가져오기-3</h3>');
    
    // for in문 - 객체를 반복하는데, 그 객체의 key값을 다 가져온다
    // 배열 객체의 key값(인덱스값)을 가져온다(권장하지 않음)
    
    for (const i in arr) {
      document.write(arr[i], '<br>');
    }
    // (참고) for in 반복문은 배열이 아니라 객체에 사용할 때 최적화되어 있어서 배열에 사용하면 객체 대비 10~100배 느림
    // 배열에 사용하는 것을 지양

    document.write('<h3>배열값 가져오기-4</h3>');
    // for of 반복문 - 객체의 요소를 가져와라, 가져온 요소는 iterator에 담음 // ES6차 문법
    for (const iterator of arr) {
      document.write(iterator, '<br>');
    }

    document.write('<h3>배열값 가져오기-5</h3>');
    // forEach()문
    arr.forEach(function (element, index) {
      document.write(index, ' ', element, '<br>');
    });

    // 배열 객체의 메소드(1)
    const arr1 = ['사당', '교대', '방배', '강남'];
    const arr2 = ['신사', '압구정', '옥수'];

    let resultArr = arr1.join('-'); // 사당-교대-방배-강남 (String)  // 배열의 값을 지정한 문자로 연결하여 하나의 문자열로 반환함
    console.log(resultArr);

    resultArr = arr1.concat(arr2); // 2개의 배열을 하나의 배열로 결합하여 새로운 배열로 반환  // concat()은 원본은 냅두고 새로운 배열로 반환함   // 원본을 변경하는 메소드도 있음 
    console.log(resultArr);

    resultArr = arr1.slice(1, 3)  // 지정된 시작과 끝위치 구간만큼 잘라내서 새로운 배열로 반환함  // index1 이상 ~ index3 전까지 배열만 반환함
    console.log(resultArr);

    arr1.sort();  // 배열의 값을 오름차순(알파벳 순, ㄱ-ㄷ 순)으로 정렬하는 메소드임 (원본 배열이 변경됨)
    console.log(arr1);

    arr2.reverse(); // 배열의 순서를 반대로 바꿈(원본 배열이 변경됨)
    console.log(arr2);

    // 배열 객체의 메소드(2) - 추가 삭제
    const greenArr = ['교대', '방배', '강남'];
    const yellowArr = ['미금', '정자', '수서'];

    // splice(index, howmany) - 배열요소를 추가하거나 제거함 (원본 배열이 변경됨)
    greenArr.splice(2, 1); // 
    console.log(greenArr);
    greenArr.splice(2, 1, '서초', '역삼'); // 몇(index)부터 몇개(howmany)를 없앨까? 그리고 '서초', '역삼'을 추가하겠다  
    console.log(greenArr);
    greenArr.splice(2, 0, '서초', '역삼'); // 삭제 없이 추가만 하고 싶을 때 howmany를 0으로 함
    console.log(greenArr);
    
    const popData = yellowArr.pop();  // 배열의 마지막을 꺼냄 (원본에서 마지막 배열이 꺼내져서 삭제됨)
    const shiftData = yellowArr.shift();  // 배열의 첫번째를 꺼냄 (원본에서 첫번째 배열이 꺼내져서 삭제됨)
    console.log(popData);
    console.log(shiftData); 
    console.log(yellowArr); 

    yellowArr.push(shiftData); // 배열의 끝에 새 요소를 추가(원본 배열이 변경됨)
    console.log(yellowArr);
    
    yellowArr.unshift(popData); // 배열의 시작 부분에 새 요소를 추가(원본 배열이 변경됨)
    console.log(yellowArr);



    // 배열 객체의 메소드(3) - 검색
    const fruits = ['Banana', 'Orange', 'Apple', 'Mango', 'Apple'];

    // indexOf() 메소드 : 지정된 값의 첫번째 인덱스(위치)를 반환, 찾을 수 없는 경우 -1
    let index = fruits.indexOf('Apple');
    console.log(index); // 가장 첫번째 동일한 요소의 index를 반환함
    index = fruits.indexOf('Apple', 3); // 검색 시작 위치 지정 'Mango'부터 검색시작함 // -1이 나오면 못찾았다는 뜻
    console.log(index);
    // includes() : 지정된 값이 포함된 경우 true, 포함되지 않은 경우 false (ES7차)
    console.log(fruits.includes('Mango'));
    console.log(fruits.includes('Man'));
    console.log(fruits.includes('Apple', 3)); // 검색 시작 위치 지정 // 3은 시작 위치! 인덱스 값이 3인 곳에서 시작









    // array.sort(비교함수) : 숫자를 정렬하기 위한 비교 함수 필요
    // 비교 함수 : function(a, b) { return a - b; }
    document.write('<h1>배열에서 숫자 데이터 정렬</h1>');
    const score = [40, 100, 65, 35, 9, 12];
    document.write(score.sort(), '<br>'); // 문자로 비교함, 100이 문자로 봤을 때 12보다 앞에 위치함
    document.write(score.sort(function(a, b) { return a - b; }), '<br>'); 
    // (오름차순) function(a, b) { return a - b; } : a - b 에서 음수가 반환되면 a, b순으로 정렬하고, 양수가 반환되면 b, a순으로 정렬한다. 0이 반환되면 변화 없음
    // (내림차순) 내림차순으로 하려면 return b - a로 변경해주면 된다







    // 2023-01-06
    // 4) 문자열 객체: 문자형 데이터에 대한 정보를 제공하고 제어하는 메서드와 속성을 제공
    // 문자열 객체 생성 2가지 방식
    // 변수 = new String('문자');
    // 변수 = '문자'; => 리터럴 방식
    document.write('<h1>문자열 정보 출력하기</h1>');
    let text = 'Hello Thank you good luck to you';  // 공백도 인덱스 포함

    document.write('<h4>특정 문자 1개 추출</h4>');
    document.write(text.charAt(16), '<br>'); // 지정된 인덱스(위치)에 있는 문자를 반환

    document.write('<h4>문자열 검색</h4>');
    document.write(text.indexOf('you'), '<br>'); //문자열에서 값이 처음 나타나는 위치를 반환, 찾을 수 없으면 -1
    document.write(text.indexOf('you', 16), '<br>'); // 검색 위치 시작 시점 지정
    document.write(text.lastIndexOf('you'), '<br>'); // 문자열 끝에서 부터 검색, 인덱스 순서는 앞에서 부터 카운트한 숫자로 반환
    document.write(text.lastIndexOf('you', 25), '<br>'); // 문자열 끝에서 부터 검색, 인덱스 순서는 앞에서 부터 카운트한 숫자로 반환 
    document.write(text.includes('you'), '<br>'); // 지정된 문자열이 포함된 경우 true, 그렇지 않으면 false
    document.write(text.includes('you', 16), '<br>'); // 검색 위치 시작 시점 지정


    document.write('<h4>문자열 추출</h4>');
    document.write(text.substr(21, 4), '<br>');  // (시작index, 문자 추출 개수) 문자열의 일부를 추출함
    document.write(text.substring(6, 12)); // 두 인덱스 사이의 문자를 추출(공백은 제외) !주의 끝인덱스의 전까지만 추출함
    // 공백은 html로 추출이 안됨으로 정확한 추출은 console.log()로 찍어보자!

    document.write('<h4>문자열 변환</h4>');
    document.write(text.replace('you', 'me'), '<br>');  // 첫번째 일치 항목을 찾아 교체된 새 문자열을 반환
    // 정규 표현식
    document.write(text.replace(/you/g, 'me'), '<br>');  // 문장에 모든 you를 교체하고 싶을 때, 정규표현식 사용함
    // /you/g  - global 전역을 돌아서 you를 찾아라
    // 정규표현식 - 입력값들에 대해서 검사를 할 때 쓰인다, 검사식을 짠다
    // 이메일 형식 정규표현식 : '^[a-zA-Z0-9+-\_.]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$'
    // 휴대폰 번호 형식의 정규 표현식 : '\d{3}-\d{3,4}-\d{4}'
    document.write(text.toLowerCase(), '<br>');  // 문장을 모두 영문 소문자로 변환 - 문자열 비교할 때, 대문자일지 소문자일지 가늠할 수 없을 때 아예 문장을 다 소문자로 변환 후 비교!!
    document.write(text.toUpperCase(), '<br>');  // 문장을 모두 영문 소문자로 변환

    document.write('<h4>문자열 길이</h4>');
    document.write(text.length, '<br>');  // 문자열의 총 길이가 추출됨

    document.write('<h4>문자열 배열로 쪼개기</h4>');
    const myArray = text.split(' '); // 구분자로 공백 문자 사용
    console.log(myArray);

    document.write('<h4>문자열 앞, 뒤 공백 제거</h4>');   // 사용자가 ID적을 때 공백을 잘못 썼을 경우 지워주는 역할 (문자 사이에 있는 공백은 제거가 안됨)
    text = '        Hello World!       ';
    console.log(text);
    console.log(text.trim());

    // 주민등록번호를 입력받은 후 정보가 노출되지 않도록 뒤의 여섯자리는 ******로 출력하세요.
    document.write('<h1>주민등록번호 마스킹</h1>');
    // const userSsn = prompt('주민등록번호를 입력하세요.');
    // const maskSsn = userSsn.substring(0, userSsn.length - 6) + '*******'; // 123456-1234567
    // document.write(maskSsn, '<br>');

    // 사용자로부터 입력받은 이메일 주소 유효성 검사(정규 표현식 안쓰는 경우)
    document.write('<h1>이메일 주소 유효성 검사</h1>');
    const userEmail = prompt('당신의 이메일 주소는?');
    const arrUrl = ['.co.kr', '.com', '.net', '.or.kr', '.go.kr'];

    let check1 = false;
    let check2 = false;

    if (userEmail.indexOf('@') > 0) { // 이메일 주소에 @ 있는지 확인
      check1 = true;
    }

    for (let i = 0; i < arrUrl.length; i++) { // 이메일 주소에 arrUrl에 요소에 있는 것 중 하나라도 있는지 확인
      if (userEmail.indexOf(arrUrl[i]) > 0) {
        check2 = true;
      }
    }

    if (check1 && check2) {  
      document.write(userEmail);
    }else{
      alert('이메일 형식이 잘못되었습니다.');
    }

    // 정규 표현식을 쓴다면, 정규표현식을 위한 검사식을 이용해서 비교하면 됨
    // 구글에서 찾아봐!! match()라는 걸 이용해서 만들기도 함!


    


















  </script>
</head>
<body>
  <!-- <h1>오늘부터 특정일까지 남은 실시간 시간</h1>
  <h2 class="d-day-count"></h2> -->

  <script>
    // (응용) D-day를 '일 시간 분 초'로 실시간 표시하기
    const tomorow = new Date(2023, 0, 7);
    const dDayCountEl = document.querySelector('.d-day-count');

    function counter() {
      const diff = tomorow.getTime() - new Date().getTime();
      // document.write(diff, '밀리초<br>');
      
      // 일수
      const dDay = Math.floor(diff / (1000 * 60 * 60 * 24));
      // document.write(diff / (1000 * 60 * 60 * 24), '일<br>');

      // 시간
      const dHour = Math.floor((diff / (1000 * 60 * 60)) % 24);
      // document.write((diff / (1000 * 60 * 60)) % 2, '시<br>');

      // 분
      const dMin = Math.floor((diff / (1000 * 60)) % 60);
      // document.write((diff / (1000 * 60)) % 6, '분<br>');

      // 초
      const dSecond = Math.floor((diff / 1000) % 60);
      // document.write((diff / 1000) % 6, '초<br>');

      dDayCountEl.textContent = `${dDay}일 ${dHour}시 ${dMin}분 ${dSecond}초`;
    }

    // setInterval(counter, 1000);
    




  </script>
  
</body>
</html>